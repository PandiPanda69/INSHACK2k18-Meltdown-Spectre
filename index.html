<!DOCTYPE html>
<html>
  <head>
    <title>Spectre et Meltdown, des failles qui vont vous hanter pendant longtemps</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">

      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Playfair+Display);
      @import url(https://fonts.googleapis.com/css?family=Zilla+Slab);

      .remark-slide-content {
          background-color: #0d47a1;
      }

      body {
          font-family: 'Playfair Display', serif;
          color: #e8eaf6;
      }

      h1, h2, h3 {
          font-family: 'Zilla Slab', sans-serif;
          font-weight: normal;
          color: #e8eaf6;
      }

      .white-bg {
          background-color: white;
      }
      .white-bg h1, .white-bg h2 {
          color: black;
      }

      .link a {
          text-decoration: none;
          color: #9fa8da;
      }

      .remark-code, .remark-inline-code {
          font-family: 'Courier New', monospace;
          font-size: 14px;
      }

      .split-the-code>pre {
          width: 49%;
          height: 100%;
          display: inline-block;
          margin-right: 2px;
          vertical-align: top;

          height: 425px;
      }

      .split-the-code>pre>code {
          height: 100%;
      }

      .bigger {
          font-size: 1.8em;
      }
      .bigger img {
          height: 10em;
      }
      .bigger .remark-inline-code {
          font-size: 1em;
      }

      .flex {
          display: flex;
          position: absolute;
          height: 100%;
      }

      .flex p {
          display: flex;
          height: 100%;
          flex: 1 1;
          flex-direction: column;
          justify-content: center;
      }

      .flex p img {
          max-width: 100%;
      }

      .full {
          display: grid;
      }
      table {
          border-collapse: collapse;
      }
      td, th {
          border: 1px solid #cccccc;
          height: 2em;
          width: 3vh;
      }

      .hidden-table>div>table td, th {
          border: none;
      }

      .float-right {
          float: right;
      }

    </style>
  </head>
  <body>
    <textarea id="source" rows="100%" cols="100%">

class: center, middle, hidden-table

# Spectre et Meltdown

### Des failles qui vont vous hanter pendant longtemps

<br/>

.full[
|Benjamin Bouvier|Sébastien Mériot|
|----------------|----------------|
|Senior Compiler Engineer @ Mozilla|Security Analyst @ OVH|
|@bnjbvr|@smeriot|
]

<br/>

#### INSHACK Lyon - 5 Avril 2018

???

Notes de celui qui parle. Si vous voyez cela, on a raté un truc.

---

class: center, middle, flex

![OVH](./img/ovh.png)

<br/>  <!-- Alors je sais pas pourquoi, mais ça rend bien. -->

![Mozilla](./img/mozilla.png)

???

Se présenter, etc.

---

class: middle, center

# L'évolution des performances

### Ou comment monter un meuble en kit efficacement

???

Warning : métaphore filée, avec ses limites, etc.

(Benjamin)

---

background-image: url('./img/ikea-pipeline.png')
background-size: 50% auto
class: white-bg

???

(Benjamin)

Un CPU lit une suite d'instructions de la meme maniere qu'un humain lit
une notice IKEA : d'abord il va récupérer l'instruction en la lisant (fetch),
puis il va l'interpréter et récupérer ce dont il a besoin avant de faire ce
qu'il désire (decode), puis il va exécuter ce qu'il faut faire et stocker le
résultat quelque part (execute).

Première manière de faire : vis par vis : aller lire, prendre la vis, puis
visser.
Autre manière plus rapide : une fois que la premiere personne a fini de lire le
manuel, une seconde personne peut lire le manuel pendant que la première
commence à récupérer la vis.

---

class: middle, center

# Fetch, Decode, Execute, etc.

.full[
|  Clock  | 1  | 2  | 3  | 4  | 5  | 6 | 7 |
|---------|----|----|----|----|----|---|---|
| Fetch   | A  |    |    | B  |    |   | C |
| Decode  |    | A  |    |    | B  |   |   |
| Execute |    |    | A  |    |    | B |   ||
]

???

(Benjamin)

Ces étapes sont mêmes décomposées en sous-cycles: entre decode et execute, va
chercher les opérandes qui sont en mémoire ; execute va également écrire le
résultat au bon endroit, etc.

---

class: middle, center

# Pipelining

.full[
|  Clock  | 1  | 2  | 3  | 4  | 5  | 6 | 7 |
|---------|----|----|----|----|----|---|---|
| Fetch   | A  | B  | C  | D  |    |   |   |
| Decode  |    | A  | B  | C  | D  |   |   |
| Execute |    |    | A  | B  | C  | D |   ||
]

???

(Benjamin)

Marche aussi conceptuellement s'il y a plus d'étapes.

---

class: middle, center

# Out-Of-Order

---

background-image: url('./img/ikea-out-of-order.png')
background-size: 100% auto
class: white-bg

???

(Sebastien)

---

class: split-the-code

## Out-of-order

```c
int main(void) {
    int  a = 0;
    int* b = &a;
    int  c = 5;

    *b += 4;
    a++;
    c = c * c;

    if (a == *b)
        return a + c;

    return 0;
}
```

---

class: split-the-code

## Out-of-order

```c
int main(void) {
    int  a = 0;
    int* b = &a;
    int  c = 5;

    *b += 4;
    a++;
    c = c * c;

    if (a == *b)
        return a + c;

    return 0;
}
```

```asm
main:
    mov eax, 30
    ret
```

---

class: split-the-code

## Out-of-order

```c
int main(void) {
    int  a = 0;
    int* b = &a;
    int  c = 5;

    *b += 4;
    a++;
    c = c * c;

    if (a == *b)
        return a + c;

    return 0;
}
```

```asm
main:
    mov eax, 0          # a = 0
    push eax
    lea edx, [ebp - 4]  # b = &a
    mov ecx, 5          # c = 5
    mov ebx, [edx]
    add ebx, 4          # b += 4
    mov [ebp - 4], ebx
    mov edx, [ebp - 4]
    inc edx             # a++
    mov [ebp - 4], edx
    push edx
    mov eax, ecx
    imul ecx            # c = c * c
    mov ecx, eax
    pop eax
    mov edx, [ebp - 4]
    cmp eax, edx        # if (a == *b)
    je equals
    mov eax, 0          # return 0
    add esp, 8
    ret

equals:
    add eax, ecx        # return a + c
    add esp, 8
    ret
```

---

class: split-the-code

## Out-of-order

```c
    *b += 4;    // int* b = &a;
    a++;
    c = c * c;
```

```asm
    add ebx, 4          # b += 4
*   mov [ebp - 4], ebx
    ################################
    mov edx, [ebp - 4]
    inc edx             # a++
    mov [ebp - 4], edx
    push edx
    ################################
    mov eax, ecx
    imul ecx            # c = c * c
    mov ecx, eax
    pop eax
```

---

class: split-the-code

## Out-of-order

```c
    *b += 4;    // int* b = &a;
    a++;
    c = c * c;
```

```asm
    add ebx, 4          # b += 4
*   mov [ebp - 4], ebx
    ################################
    mov edx, [ebp - 4]
    inc edx             # a++
    mov [ebp - 4], edx
    push edx
    ################################
*   mov eax, ecx
*   imul ecx            # c = c * c
*   mov ecx, eax
    pop eax
```

---

class: middle, center

## Spéculation

---

background-image: url('./img/ikea-speculation.png')
background-size: 100% auto
class: white-bg

???

(Sebastien)

jusqu'a 200 instructions exécutées spéculativement.

---

class: split-the-code

## Spéculation

```c
    if (a == *b)
        return a + c;

    return 0;
```

```asm
    pop eax

*   cmp eax, [ebp - 4]  # if (a == *b)
    je equals
    mov eax, 0          # return 0
    add esp, 8
    ret

equals:
    add eax, ecx        # return a + c
    add esp, 8
    ret

```

---

class: split-the-code

## Spéculation

```c
    void(*func_ptr) (int) = NULL;

    func_ptr = foo;
    func_ptr(5);
```

```asm
    mov eax, 0      # func_ptr = NULL

    mov eax, [foo]  # func_ptr = foo
    push 5
*   call eax        # func_ptr(5)
    sub edp, 4
```

---

## Spéculation

- Branch History Buffer
    - Mapping entre `addr_src` et `addr_dest`

- Branch Target Buffer
    - Mapping des `(sizeof(addr) / 2) - 1` bits

---

class: white-bg, center
background-image: url('./img/cache.jpg')
background-size: 50% auto

# Cache

???

Localité temporelle : Les données utilisées récemment ont de grosses chances
d'être réutilisées bientôt par la suite => les mettre à un endroit proche du
processeur pour diminuer le temps d'accès (latence).

=> Exemple : tournevis.

Localité spatiale : les données proches d'une donnée utilisée récemment vont
probablement être utilisées par la suite => regrouper les accès mémoire en
lignes de cache.

=> Exemple : vis.

Application : plusieurs caches placés les uns à la suite des autres.

Cache code vs cache données.

Plus proche du processeur => plus rapide d'accès, plus cher aussi.

- Politique d'évictions différentes (LRU pour L1, LRU/MRU pour L3)
- Mapping peu documenté (reverse engineeré)

---

class: middle, center

# Cache - Latences

.full[
|  Type  | Latence |
|---------|----|
| Cycle CPU (2Ghz)      | ~0.5 ns |
| L1 cache reference    | ~0.5 ns |
| L2 cache reference    | 4 ns |
| Main memory reference | 100 ns |
| 1MB data sequential read from memory       | 6,000 ns |
| SSD random read       | 16,000 ns |
| 1MB data sequential read from SSD       | 98,000 ns |
| 1MB data sequential read from disk       | 1,000,000 ns |
| Disk seek       | 3,000,000 ns |
]

???

Extrait de "Latency numbers every programmer should know."

---

class: white-bg, middle, center

![Spectre logo](./img/spectre.svg)

---

class: white-bg, center
background-image: url('./img/timer.jpg')
background-size: 50% auto

## Cache-based side-channel attack

???

(Benjamin, pendant que Seb fait la démo)

---

# Spectre : variante 1

```c
let target_array = new Uint8Array(TARGET_SIZE);
let probe_array = new Uint8Array(BIG_SIZE * 256);

...

// Precondition: - target_array_length not in cache,
//               - index, target_array[index], probe_array in cache.
let r = 0;
if (index < target_array.length) {
    let read_value = target_array[index];
    let x = probe_array[(read_value & 8) * BIG_SIZE];
    r += x;
}
```

--

```
let hits = new Uint8Array(256);
let r = 0;
for (let i = 0; i < 256; i++) {
      let before = performance.now();
      r = probe_array[i];
      if (performance.now() - before < THRESHOLD) {
          hits[i]++;
      }
}
```

???

- Attaquant : entrainer la branche pour qu'elle soit toujours prise, afin que
le prédicteur de branche.
- s'arranger pour faire des appels valides avec des valeurs qui nous
intéressent, afin d'entrainer les caches.

- Race condition entre la vérification de la branche et l'exécution spéculative
de la seconde lecture.
- Besoin de timers haute précision pour mesurer le temps d'accès.

Pas limité à des bounds checks, on peut le faire sur n'importe quelle adresse
mémoire, avec n'importe quelle condition tant qu'un des opérandes n'est pas
dans l'un des caches.

Plusieurs preuves de concept dans tous les navigateurs.

---

class: bigger

# Mitigations : timers

--

- API `SharedArrayBuffer` dans les navigateurs

--

- Résolution de `performance.now()` diminuée

--

- `performance.now()` += erreur aléatoire

---

class: bigger

# Mitigations : lfence

`The software mitigation that Intel recommends is to insert a barrier to stop
speculation in appropriate places.`

--

.float-right[![nope](./img/nope.jpg)]

---

class: bigger

# Mitigations : mask

Arrondir les tailles de tableaux à la puissance de deux supérieure.

--

```
// Say target_array.length is really 23,
// rounded by the compiler to 32 = 0b00100000.
// Then target_array.MASK = 0b00011111.
if (index < target_array.length) {
*   // Added by compiler:
*   let new_index = index & target_array.MASK;
    let read_value = target_array[new_index];
*   let new_index2 = ((read_value & 8) * BIG_SIZE) & probe_array.MASK;
    let x = probe_array[new_index2];
    r += x;
}
```

---

class: bigger

# Mitigations : `cmovcc`

--

`cmovcc`: check the state of one or more of the status flags in the EFLAGS
register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are
in a specified state (or condition).

--

*not* speculated!

--

```
if (index < target_array.length) {
*   // Added by compiler:
*   let new_index = index;
*   new_index = cmovcc(new_index >= target_array.length, 0);
    let read_value = target_array[new_index];
*   let new_index2 = ((read_value & 8) * BIG_SIZE);
*   new_index2 = cmovcc(new_index2 >= probe_array.length, 0);
    let x = probe_array[new_index2];
    r += x;
}
```

---

# Spectre : variante 2

???

TODO

---

# Impact sur les performances

???

TODO : Screenshot AWFY

---

class: middle, center

# Q&A

---

# Références / Sources

- Old watch : photo by Veri Ivanova on Unsplash.

- https://webkit.org/blog/8048/what-spectre-and-meltdown-mean-for-webkit/

---

class: middle, center

# Merci !

???

Commentaires, questions?

    </textarea>
    <script src="remark.js">
    </script>
    <script>
var slideshow = remark.create({
    highlightLanguage: "javascript",
    highlightLines: true,
    countIncrementalSlides: false
});
    </script>
  </body>
</html>
